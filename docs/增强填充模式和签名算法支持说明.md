# 增强填充模式和签名算法支持说明

## 概述

本次更新为加密工具库添加了更丰富的填充模式和签名算法支持，使开发者能够根据不同的安全需求和兼容性要求选择合适的加密参数。

## 主要新增功能

### 1. 扩展的填充模式支持

#### 非对称加密填充模式 (AsymmetricPaddingMode)
- **PKCS1**: PKCS#1 v1.5填充 - 传统RSA填充模式
- **OAEP**: OAEP填充 - 更安全的RSA填充模式
- **PSS**: PSS填充 - 用于RSA签名的安全填充模式
- **None**: 无填充 - 要求数据长度必须是密钥长度的整数倍

#### 对称加密填充模式 (SymmetricPaddingMode)
- **PKCS7**: PKCS7填充（推荐）- 最常用的标准填充模式
- **PKCS5**: PKCS5填充 - 与PKCS7类似，但专门用于8字节块大小
- **Zeros**: 零填充 - 使用零字节填充
- **ISO10126**: ISO10126填充 - 使用随机字节填充，最后一字节表示填充长度
- **ANSIX923**: ANSIX923填充 - 填充字节为零，最后一字节表示填充长度
- **None**: 无填充 - 要求输入数据长度必须是块大小的整数倍

### 2. 扩展的签名算法支持

#### RSA签名算法
- **MD5withRSA**: MD5withRSA - 使用MD5哈希的RSA签名（不推荐，安全性较低）
- **SHA1withRSA**: SHA1withRSA - 使用SHA1哈希的RSA签名（不推荐，安全性较低）
- **SHA256withRSA**: SHA256withRSA - 使用SHA256哈希的RSA签名（推荐）
- **SHA384withRSA**: SHA384withRSA - 使用SHA384哈希的RSA签名（推荐）
- **SHA512withRSA**: SHA512withRSA - 使用SHA512哈希的RSA签名（推荐）
- **SHA1withRSA_PSS**: SHA1withRSA-PSS - 使用SHA1哈希和PSS填充的RSA签名
- **SHA256withRSA_PSS**: SHA256withRSA-PSS - 使用SHA256哈希和PSS填充的RSA签名（推荐）
- **SHA384withRSA_PSS**: SHA384withRSA-PSS - 使用SHA384哈希和PSS填充的RSA签名（推荐）
- **SHA512withRSA_PSS**: SHA512withRSA-PSS - 使用SHA512哈希和PSS填充的RSA签名（推荐）

#### SM2签名算法
- **SM3withSM2**: SM3withSM2 - 使用SM3哈希的SM2签名（国密标准）

#### 其他签名算法（预留）
- **ECDSAwithSHA1**: ECDSAwithSHA1 - 使用SHA1哈希的ECDSA签名
- **ECDSAwithSHA256**: ECDSAwithSHA256 - 使用SHA256哈希的ECDSA签名
- **ECDSAwithSHA384**: ECDSAwithSHA384 - 使用SHA384哈希的ECDSA签名
- **ECDSAwithSHA512**: ECDSAwithSHA512 - 使用SHA512哈希的ECDSA签名
- **EdDSA**: EdDSA - 使用Ed25519曲线的EdDSA签名
- **DSAwithSHA1**: DSAwithSHA1 - 使用SHA1哈希的DSA签名
- **DSAwithSHA256**: DSAwithSHA256 - 使用SHA256哈希的DSA签名

## 使用方法

### 1. RSA算法使用示例

```csharp
using CryptoTool.Algorithm.Algorithms.RSA;
using CryptoTool.Algorithm.Enums;

// 创建RSA实例
var rsa = new RsaCrypto(2048);

// 生成密钥对
var (publicKey, privateKey) = rsa.GenerateKeyPair();

// 使用指定填充模式加密
var data = Encoding.UTF8.GetBytes("Hello, World!");
var encrypted = rsa.Encrypt(data, publicKey, AsymmetricPaddingMode.OAEP);
var decrypted = rsa.Decrypt(encrypted, privateKey, AsymmetricPaddingMode.OAEP);

// 使用指定签名算法签名
var signature = rsa.Sign(data, privateKey, SignatureAlgorithm.SHA256withRSA_PSS);
var isValid = rsa.VerifySign(data, signature, publicKey, SignatureAlgorithm.SHA256withRSA_PSS);

// 异步操作
var encryptedAsync = await rsa.EncryptAsync(data, publicKey, AsymmetricPaddingMode.PKCS1);
var signatureAsync = await rsa.SignAsync(data, privateKey, SignatureAlgorithm.SHA512withRSA);
```

### 2. SM2算法使用示例

```csharp
using CryptoTool.Algorithm.Algorithms.SM2;
using CryptoTool.Algorithm.Enums;

// 创建SM2实例
var sm2 = new Sm2Crypto();

// 生成密钥对
var (publicKey, privateKey) = sm2.GenerateKeyPair();

// 使用指定填充模式加密（SM2只支持PKCS1）
var data = Encoding.UTF8.GetBytes("Hello, 世界!");
var encrypted = sm2.Encrypt(data, publicKey, AsymmetricPaddingMode.PKCS1);
var decrypted = sm2.Decrypt(encrypted, privateKey, AsymmetricPaddingMode.PKCS1);

// 使用指定签名算法签名（SM2只支持SM3withSM2）
var signature = sm2.Sign(data, privateKey, SignatureAlgorithm.SM3withSM2);
var isValid = sm2.VerifySign(data, signature, publicKey, SignatureAlgorithm.SM3withSM2);
```

### 3. 查询支持的算法

```csharp
// 查询RSA支持的签名算法
var rsaAlgorithms = rsa.GetSupportedSignatureAlgorithms();
foreach (var algorithm in rsaAlgorithms)
{
    Console.WriteLine($"RSA支持: {algorithm}");
}

// 查询RSA支持的填充模式
var rsaPaddingModes = rsa.GetSupportedPaddingModes();
foreach (var paddingMode in rsaPaddingModes)
{
    Console.WriteLine($"RSA支持: {paddingMode}");
}

// 查询SM2支持的算法
var sm2Algorithms = sm2.GetSupportedSignatureAlgorithms();
var sm2PaddingModes = sm2.GetSupportedPaddingModes();
```

## 安全建议

### 1. 填充模式选择
- **PKCS1**: 适用于传统系统兼容性要求，但安全性相对较低
- **OAEP**: 推荐用于新系统，提供更好的安全性
- **PSS**: 推荐用于签名操作，提供最佳安全性

### 2. 签名算法选择
- **SHA256withRSA**: 推荐用于一般用途，平衡了安全性和性能
- **SHA512withRSA**: 推荐用于高安全要求场景
- **SHA256withRSA_PSS**: 推荐用于需要最高安全性的签名场景
- **SM3withSM2**: 推荐用于需要符合国密标准的场景

### 3. 不推荐的算法
- **MD5withRSA**: MD5已被认为不安全，不推荐使用
- **SHA1withRSA**: SHA1已被认为安全性不足，不推荐使用

## 错误处理

### 1. 不支持的填充模式
```csharp
try
{
    var encrypted = sm2.Encrypt(data, publicKey, AsymmetricPaddingMode.OAEP);
}
catch (NotSupportedException ex)
{
    Console.WriteLine($"SM2不支持OAEP填充: {ex.Message}");
}
```

### 2. 不支持的签名算法
```csharp
try
{
    var signature = sm2.Sign(data, privateKey, SignatureAlgorithm.SHA256withRSA);
}
catch (CryptoException ex)
{
    Console.WriteLine($"SM2不支持该签名算法: {ex.Message}");
}
```

## 性能考虑

### 1. 填充模式性能
- **PKCS1**: 性能最好，但安全性较低
- **OAEP**: 性能中等，安全性较高
- **PSS**: 性能稍低，但安全性最高

### 2. 签名算法性能
- **SHA256**: 性能最好，安全性良好
- **SHA512**: 性能稍低，但安全性更高
- **PSS填充**: 比PKCS1填充稍慢，但更安全

## 兼容性说明

### 1. 向后兼容性
- 所有原有的方法调用仍然有效
- 新增的方法不会影响现有代码
- 默认行为保持不变

### 2. 跨平台兼容性
- 所有新功能都基于.NET Standard 2.1
- 支持Windows、Linux、macOS等平台
- 与现有BouncyCastle库完全兼容

## 测试验证

项目包含了完整的测试用例来验证新功能：

```csharp
// 运行增强功能测试
var enhancedTest = new EnhancedCryptoTest();
await enhancedTest.RunAllTests();
```

测试包括：
- RSA多种填充模式测试
- RSA多种签名算法测试
- SM2签名算法测试
- 算法兼容性检查
- 错误处理测试

## 总结

本次更新大大增强了加密工具库的功能性和灵活性，使开发者能够：

1. 根据安全需求选择合适的填充模式
2. 根据性能要求选择合适的签名算法
3. 确保与不同系统的兼容性
4. 获得更好的错误处理和调试信息

这些增强功能使加密工具库更加专业和实用，能够满足各种复杂的加密需求。
